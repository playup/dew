#!/usr/bin/env ruby
require 'dew'

class DewCommand < DewBaseCommand
  option ['-r', '--region'], "REGION", "AWS region", :default => ENV['DEW_REGION'] || 'ap-southeast-1'
  option ['-a', '--account'], "ACCOUNT", "AWS account", :default => ENV['DEW_ACCOUNT'] || 'development'
  option ['-q', '--quiet'], :flag, "Quiet mode, disables logging", :default => false
  option ['-v', '--verbose'], :flag, "Verbose mode, print debug output", :default => ENV['DEW_VERBOSE']
  option '--debug', :flag, "Show stacktraces on error", :default => false
  option '--version', :flag, "Prints the dew version" do
    puts "dew version #{Dew::VERSION}"
    exit(0)
  end

  subcommand "environments", "perform subcommands on the environments", EnvironmentsCommand
  subcommand "amis", "perform subcommands on the AMIs", AMIsCommand
  subcommand "deploy", "deploy to an environment", DeployCommand
  subcommand "console", "open an IRB session with Cloud loaded", ConsoleCommand
  subcommand "tidy", "tidy up resources left behind by automated tests", TidyCommand

  def configure
    $debug = debug?
    Inform.level = quiet? ? :warning : (verbose? ? :debug : :info)
    Cloud.connect(region, account)
  end

  def run(args)
    (puts help ; exit 1) if args.empty?
    super
  end


  def execute
    begin
      super
    rescue Clamp::HelpWanted => e
      raise
    rescue Clamp::UsageError => e
      Inform.error(e.message)
      puts e.command.help
      exit(1)
    rescue Interrupt => e
      # If receive ^C Just exit the script...
      Inform.error("Interrupt Received.")
    rescue Exception => e
      error_message = ''
      error_args = {:trace_filename => write_backtrace(e)}
      
      if e.is_a? Excon::Errors::HTTPStatusError
        error_args[:excon] = parse_excon_error_response(e)
        error_message = "AWS Error: %{excon}"        
      else
        error_message += e.message
      end
      error_message += "\n(see %{trace_filename} for more details)\n"

      if $debug or ENV['AWS_DEBUG']
        Inform.error(error_message, error_args)
        raise
      else
        error_message += "(and/or run again with %{flag} flag, or %{env} in your environment)\n"
        error_args.merge!(:flag => "--debug", :env => "AWS_DEBUG=1")
        Inform.error(error_message, error_args)
        Kernel.exit 1
      end
    end
  end
  
  private
  
  def parse_excon_error_response e
    begin
      require 'nokogiri'
      Nokogiri::XML.parse(e.response.body).css('Message').first.content
    rescue
      e.message
    end
  end

  def write_backtrace e
    trace_filename = "/tmp/#{invocation_path}-#{Time.now.strftime("%Y%m%d%H%M%S")}.txt"
    File.open(trace_filename, 'w') do |f|
      backtrace = (["#{e.backtrace.shift}: #{e.message} (#{e.class})"] + e.backtrace).join("\n\t")
      f.write("#{self.inspect}\n\n#{backtrace}\n")
      f.close
    end
    trace_filename
  end
end

DewCommand.run
